package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/sirupsen/logrus"
)

const defaultConfigFilename = "import-aliases.config.go"

type options struct {
	rootDir    string
	configFile string

	dumpInto string
}

func newOptions() *options {
	o := &options{}
	return o
}

func (o *options) addFlags(fs *flag.FlagSet) {
	fs.StringVar(&o.rootDir, "root-dir", o.rootDir, "Path to the directory in which Alias checking should occur.")
	fs.StringVar(&o.configFile, "config", o.configFile, fmt.Sprintf("Path to an %s file to inform Alias checking.", defaultConfigFilename))

	fs.StringVar(&o.dumpInto, "dump-dir", o.dumpInto, fmt.Sprintf("Path to a directory where current usage will be dumped into a %s file.", defaultConfigFilename))
}

func (o *options) complete() error {
	return nil
}

func (o *options) validate() error {
	if o.rootDir == "" {
		return errors.New("--root-dir is required")
	}

	if o.configFile == "" && o.dumpInto == "" {
		return errors.New("either --config or --root-dir is required")
	}

	return nil
}

func main() {
	o := newOptions()
	o.addFlags(flag.CommandLine)
	flag.Parse()
	if err := o.complete(); err != nil {
		logrus.WithError(err).Fatal("could not complete options")
	}
	if err := o.validate(); err != nil {
		logrus.WithError(err).Fatal("invalid options")
	}
	if o.dumpInto != "" {
		if err := dumpInto(o.rootDir, o.dumpInto); err != nil {
			logrus.WithError(err).Fatal("failed to dump current aliases")
		}
		return
	} else {
		if err := rewrite(o.rootDir, o.configFile); err != nil {
			logrus.WithError(err).Fatal("failed to re-write source")
		}
	}
}

func dumpInto(fromDir, toDir string) error {
	imports := map[string]map[string]int{}
	fileset := token.NewFileSet()
	if err := filepath.WalkDir(fromDir, func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			return nil
		}
		packages, err := parser.ParseDir(fileset, path, nil, 0666)
		if err != nil {
			return err
		}

		for _, pkg := range packages {
			for _, file := range pkg.Files {
				if generated(file) {
					continue
				}
				for _, imprt := range file.Imports {
					if _, exists := imports[imprt.Path.Value]; !exists {
						imports[imprt.Path.Value] = map[string]int{}
					}
					var alias string
					if imprt.Name == nil {
						alias = ""
					} else {
						alias = imprt.Name.Name
					}
					imports[imprt.Path.Value][alias] += 1
				}
			}
		}
		return nil
	}); err != nil {
		return fmt.Errorf("failed to parse source: %w", err)
	}

	type aliasRecord struct {
		Alias string
		Count int
	}
	type aliasRecords struct {
		Path    string
		Records []aliasRecord
	}

	var records []aliasRecords
	for path, aliases := range imports {
		if len(aliases) == 1 {
			continue
		}
		var orderedAliases []aliasRecord
		for alias, count := range aliases {
			if alias == "_" {
				continue
			}
			orderedAliases = append(orderedAliases, aliasRecord{Alias: alias, Count: count})
		}
		sort.Slice(orderedAliases, func(i, j int) bool {
			return orderedAliases[i].Count > orderedAliases[j].Count
		})
		records = append(records, aliasRecords{
			Path:    path,
			Records: orderedAliases,
		})
	}
	sort.Slice(records, func(i, j int) bool {
		return records[i].Path < records[j].Path
	})

	tmpl, err := template.New("import-aliases.config.go").Parse(`
package main

import (
{{- range $package := . -}}{{ range .Records }}
	{{ .Alias }} {{ $package.Path }} /* used {{ .Count }} time{{ if gt .Count 1 }}s{{ end }} */
{{- end }}
{{ end -}}
)
`)
	if err != nil {
		return fmt.Errorf("failed to create configuration template: %w", err)
	}

	outputPath := filepath.Join(toDir, defaultConfigFilename)
	output, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to open output file %s: %w", outputPath, err)
	}
	defer func() {
		if err := output.Close(); err != nil {
			logrus.WithError(err).Error("could not close output file")
		}
	}()
	if err := tmpl.Execute(output, records); err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputPath, err)
	}

	logrus.Infof("wrote summary to %s", outputPath)
	return nil
}

func generated(file *ast.File) bool {
	for _, commentGroup := range file.Comments {
		for _, comment := range commentGroup.List {
			if strings.Contains(comment.Text, "Code generated by") {
				return true
			}
		}
	}
	return false
}

func rewrite(fromDir string, configFile string) error {
	cfg, err := loadConfiguration(configFile)
	if err != nil {
		return err
	}

	fileset := token.NewFileSet()
	var rewriteErrors bool
	var toUpdate []func() error
	if err := filepath.WalkDir(fromDir, func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			return nil
		}
		packages, err := parser.ParseDir(fileset, path, nil, 0666)
		if err != nil {
			return err
		}

		for _, pkg := range packages {
			for filePath, file := range pkg.Files {
				relPath, err := filepath.Rel(fromDir, filePath)
				if err != nil {
					return fmt.Errorf("should not happen: could not find relative path to %s from %s", filePath, fromDir)
				}
				if generated(file) {
					continue
				}
				for i, imprt := range file.Imports {
					alias, exists := cfg[imprt.Path.Value]
					if !exists {
						continue
					}
					switch {
					case alias == "" && imprt.Name == nil:
						// expected no alias, have no alias, all good
						continue
					case alias != "" && imprt.Name != nil && imprt.Name.Name == alias:
						// expected an alias, got the alias, all good
						continue
					}
					ourName := alias
					if ourName == "" {
						ourName = implicitName(imprt)
					}
					for j, other := range file.Imports {
						if i == j || imprt.Path.Value == other.Path.Value {
							continue
						}
						theirName := effectiveName(other)
						if ourName != theirName {
							continue
						}
						var err string
						if alias == "" {
							err = fmt.Sprintf("%s: removing the alias for %s would cause a collision with %s", relPath, imprt.Path.Value, other.Path.Value)
						} else {
							err = fmt.Sprintf("%s: aliasing %s as %s would cause a collision with %s", relPath, imprt.Path.Value, alias, other.Path.Value)
						}
						if err != "" {
							logrus.Error(err)
							rewriteErrors = true
						}
					}
					if !rewriteErrors {
						if alias == "" {
							imprt.Name = nil
						} else {
							if imprt.Name == nil {
								imprt.Name = &ast.Ident{}
							}
							imprt.Name.Name = alias
						}
						toUpdate = append(toUpdate, func(fileset *token.FileSet, file *ast.File, relPath string) func() error {
							return func() error {
								f, err := os.OpenFile(filepath.Join(fromDir, relPath), os.O_RDWR, 0666)
								if err != nil {
									return fmt.Errorf("failed to open %s for writing: %w", relPath, err)
								}
								if err := format.Node(f, fileset, file); err != nil {
									return fmt.Errorf("failed to write %s: %w", relPath, err)
								}
								return nil
							}
						}(fileset, file, relPath))
					}
				}
			}
		}
		return nil
	}); err != nil {
		return fmt.Errorf("failed to parse source: %w", err)
	}

	if rewriteErrors {
		return errors.New("re-writing aliases would cause compilation errors")
	}

	for _, u := range toUpdate {
		if err := u(); err != nil {
			return err
		}
	}
	return nil
}

func effectiveName(imprt *ast.ImportSpec) string {
	if imprt.Name == nil {
		return implicitName(imprt)
	}
	return imprt.Name.Name
}

func implicitName(imprt *ast.ImportSpec) string {
	_, path := filepath.Split(strings.Trim(imprt.Path.Value, `""`))
	return path
}

// aliasConfiguration maps import package paths to their preferred import alias
type aliasConfiguration map[string]string

func loadConfiguration(configFile string) (aliasConfiguration, error) {
	fileset := token.NewFileSet()
	astFile, err := parser.ParseFile(fileset, configFile, nil, 0666)
	if err != nil {
		return nil, fmt.Errorf("failed to load configuration: %w", err)
	}

	config := aliasConfiguration{}
	var duplicates []string
	var invalid []string
	for _, imprt := range astFile.Imports {
		if _, exists := config[imprt.Path.Value]; exists {
			duplicates = append(duplicates, imprt.Path.Value)
			continue
		}

		var alias string
		if imprt.Name == nil {
			alias = ""
		} else {
			alias = imprt.Name.Name
		}
		if alias == "_" {
			invalid = append(invalid, "side-effect import of %s", imprt.Path.Value)
			continue
		}
		config[imprt.Path.Value] = alias
	}
	if len(duplicates) > 0 {
		return nil, fmt.Errorf("duplicate aliases found for %s", strings.Join(duplicates, ", "))
	}
	if len(invalid) > 0 {
		return nil, fmt.Errorf("invalid aliases found: %s", strings.Join(invalid, ", "))
	}

	return config, nil
}
