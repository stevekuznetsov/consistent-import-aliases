package main

import (
	"errors"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/gopackages"
	"github.com/sirupsen/logrus"
	"golang.org/x/tools/go/packages"
)

const defaultConfigFilename = "import-aliases.config.go"

type options struct {
	packageNames []string
	configFile   string

	dumpInto string
}

func newOptions() *options {
	o := &options{}
	return o
}

func (o *options) addFlags(fs *flag.FlagSet) {
	fs.StringVar(&o.configFile, "config", o.configFile, fmt.Sprintf("Path to an %s file to inform Alias checking.", defaultConfigFilename))

	fs.StringVar(&o.dumpInto, "dump-dir", o.dumpInto, fmt.Sprintf("Path to a directory where current usage will be dumped into a %s file.", defaultConfigFilename))
}

func (o *options) complete(args []string) error {
	o.packageNames = args
	return nil
}

func (o *options) validate() error {
	if len(o.packageNames) == 0 {
		return errors.New("packages to scan are required arguments")
	}

	if o.configFile == "" && o.dumpInto == "" {
		return errors.New("either --config or --root-dir is required")
	}

	return nil
}

func main() {
	o := newOptions()
	o.addFlags(flag.CommandLine)
	flag.Parse()
	if err := o.complete(flag.Args()); err != nil {
		logrus.WithError(err).Fatal("could not complete options")
	}
	if err := o.validate(); err != nil {
		logrus.WithError(err).Fatal("invalid options")
	}
	if o.dumpInto != "" {
		if err := dumpInto(o.packageNames, o.dumpInto); err != nil {
			logrus.WithError(err).Fatal("failed to dump current aliases")
		}
		return
	} else {
		if err := rewrite(o.packageNames, o.configFile); err != nil {
			logrus.WithError(err).Fatal("failed to re-write source")
		}
	}
}

func dumpInto(packageNames []string, toDir string) error {
	pkgs, err := decorator.Load(&packages.Config{Mode: packages.LoadSyntax}, packageNames...)
	if err != nil {
		return fmt.Errorf("failed to load source: %w", err)
	}
	imports := map[string]map[string]int{}
	for _, pkg := range pkgs {
		for i, file := range pkg.Syntax {
			relPath, err := filepath.Rel(pkg.Dir, pkg.CompiledGoFiles[i])
			if err != nil {
				return fmt.Errorf("should not happen: could not find relative path to %s from %s", pkg.CompiledGoFiles[i], pkg.Dir)
			}
			if generated(file) {
				logrus.WithField("file", relPath).Debug("Skipping generated file.")
				continue
			}
			for _, imprt := range file.Imports {
				if _, exists := imports[imprt.Path.Value]; !exists {
					imports[imprt.Path.Value] = map[string]int{}
				}
				var alias string
				if imprt.Name == nil {
					alias = ""
				} else {
					alias = imprt.Name.Name
				}
				imports[imprt.Path.Value][alias] += 1
			}
		}
	}

	type aliasRecord struct {
		Alias string
		Count int
	}
	type aliasRecords struct {
		Path    string
		Records []aliasRecord
	}

	var records []aliasRecords
	for path, aliases := range imports {
		if len(aliases) == 1 {
			continue
		}
		var orderedAliases []aliasRecord
		for alias, count := range aliases {
			if alias == "_" {
				continue
			}
			orderedAliases = append(orderedAliases, aliasRecord{Alias: alias, Count: count})
		}
		sort.Slice(orderedAliases, func(i, j int) bool {
			return orderedAliases[i].Count > orderedAliases[j].Count
		})
		records = append(records, aliasRecords{
			Path:    path,
			Records: orderedAliases,
		})
	}
	sort.Slice(records, func(i, j int) bool {
		return records[i].Path < records[j].Path
	})

	tmpl, err := template.New("import-aliases.config.go").Parse(`
package main

import (
{{- range $package := . -}}{{ range .Records }}
	{{ .Alias }} {{ $package.Path }} /* used {{ .Count }} time{{ if gt .Count 1 }}s{{ end }} */
{{- end }}
{{ end -}}
)
`)
	if err != nil {
		return fmt.Errorf("failed to create configuration template: %w", err)
	}

	outputPath := filepath.Join(toDir, defaultConfigFilename)
	output, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to open output file %s: %w", outputPath, err)
	}
	defer func() {
		if err := output.Close(); err != nil {
			logrus.WithError(err).Error("could not close output file")
		}
	}()
	if err := tmpl.Execute(output, records); err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputPath, err)
	}

	logrus.Infof("wrote summary to %s", outputPath)
	return nil
}

func generated(file *dst.File) bool {
	for _, comment := range file.Decs.Start {
		if strings.Contains(comment, "Code generated by") {
			return true
		}
	}
	return false
}

func rewrite(packageNames []string, configFile string) error {
	cfg, err := loadConfiguration(configFile)
	if err != nil {
		return err
	}

	var rewriteErrors bool
	var toUpdate []func() error
	pkgs, err := decorator.Load(nil, packageNames...)
	if err != nil {
		return fmt.Errorf("failed to load source: %w", err)
	}
	for _, pkg := range pkgs {
		restorer := decorator.NewRestorerWithImports(pkg.PkgPath, gopackages.New(""))
		fileRestorer := restorer.FileRestorer()
		for quotedPackagePath, alias := range cfg {
			packagePath, err := strconv.Unquote(quotedPackagePath)
			if err != nil {
				return fmt.Errorf("failed to unquote package path %s: %w", quotedPackagePath, err)
			}
			if alias == "" {
				delete(fileRestorer.Alias, packagePath)
			} else {
				fileRestorer.Alias[packagePath] = alias
			}
		}
		for i, file := range pkg.Syntax {
			filePath := pkg.CompiledGoFiles[i]
			relPath, err := filepath.Rel(pkg.Dir, filePath)
			if err != nil {
				return fmt.Errorf("should not happen: could not find relative path to %s from %s", filePath, pkg.Dir)
			}
			if generated(file) {
				continue
			}
			needsUpdate := false
			for j, imprt := range file.Imports {
				alias, exists := cfg[imprt.Path.Value]
				if !exists {
					continue
				}
				switch {
				case alias == "" && imprt.Name == nil:
					// expected no alias, have no alias, all good
					continue
				case alias != "" && imprt.Name != nil && imprt.Name.Name == alias:
					// expected an alias, got the alias, all good
					continue
				}
				ourName := alias
				if ourName == "" {
					ourName = implicitName(imprt)
				}
				for k, other := range file.Imports {
					if j == k || imprt.Path.Value == other.Path.Value {
						continue
					}
					theirName := effectiveName(other)
					if ourName != theirName {
						continue
					}
					var err string
					if alias == "" {
						err = fmt.Sprintf("%s: removing the alias for %s would cause a collision with %s", relPath, imprt.Path.Value, other.Path.Value)
					} else {
						err = fmt.Sprintf("%s: aliasing %s as %s would cause a collision with %s", relPath, imprt.Path.Value, alias, other.Path.Value)
					}
					if err != "" {
						logrus.Error(err)
						rewriteErrors = true
					}
				}
				needsUpdate = !rewriteErrors
			}
			if needsUpdate {
				toUpdate = append(toUpdate, func(path string, file *dst.File, relPath string) func() error {
					return func() error {
						logrus.WithField("file", relPath).Info("Updating file.")
						f, err := os.OpenFile(path, os.O_RDWR, 0666)
						if err != nil {
							return fmt.Errorf("failed to open %s for writing: %w", relPath, err)
						}
						if err := fileRestorer.Fprint(f, file); err != nil {
							return fmt.Errorf("failed to write %s: %w", relPath, err)
						}
						return nil
					}
				}(filePath, file, relPath))
			}
		}
	}

	if rewriteErrors {
		return errors.New("re-writing aliases would cause compilation errors")
	}

	var failed bool
	for _, u := range toUpdate {
		if err := u(); err != nil {
			logrus.WithError(err).Error("failed to update file")
			failed = true
		}
	}
	if failed {
		return errors.New("failed to update all files")
	}
	return nil
}

func effectiveName(imprt *dst.ImportSpec) string {
	if imprt.Name == nil {
		return implicitName(imprt)
	}
	return imprt.Name.Name
}

func implicitName(imprt *dst.ImportSpec) string {
	_, path := filepath.Split(strings.Trim(imprt.Path.Value, `""`))
	return path
}

// aliasConfiguration maps import package paths to their preferred import alias
type aliasConfiguration map[string]string

func loadConfiguration(configFile string) (aliasConfiguration, error) {
	fileset := token.NewFileSet()
	astFile, err := parser.ParseFile(fileset, configFile, nil, 0666)
	if err != nil {
		return nil, fmt.Errorf("failed to load configuration: %w", err)
	}

	config := aliasConfiguration{}
	var duplicates []string
	var invalid []string
	for _, imprt := range astFile.Imports {
		if _, exists := config[imprt.Path.Value]; exists {
			duplicates = append(duplicates, imprt.Path.Value)
			continue
		}

		var alias string
		if imprt.Name == nil {
			alias = ""
		} else {
			alias = imprt.Name.Name
		}
		if alias == "_" {
			invalid = append(invalid, "side-effect import of %s", imprt.Path.Value)
			continue
		}
		config[imprt.Path.Value] = alias
	}
	if len(duplicates) > 0 {
		return nil, fmt.Errorf("duplicate aliases found for %s", strings.Join(duplicates, ", "))
	}
	if len(invalid) > 0 {
		return nil, fmt.Errorf("invalid aliases found: %s", strings.Join(invalid, ", "))
	}

	return config, nil
}
